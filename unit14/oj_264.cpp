// 264
// 仙境的居民们决定举办一场程序设计区域赛。裁判委员会完全由自愿组成，他们承诺要组织一次史上最公正的比赛。
// 他们决定将选手的电脑用星形拓扑结构连接在一起，即将它们全部连到一个单一的中心服务器。为了组织这个完全公正的比赛，
// 裁判委员会主席提出要将所有选手的电脑等距离地围绕在服务器周围放置。 为购买网线，裁判委员会联系了当地的一个网络解决
// 方案提供商，要求能够提供一定数量的等长网线。裁判委员会希望网线越长越好，这样选手们之间的距离可以尽可能远一些。 
// 该公司的网线主管承接了这个任务。他知道库存中每条网线的长度（精确到厘米），并且只要告诉他所需的网线长度（精确到厘米），
// 他都能够完成对网线的切割工作。但是，这次，所需的网线长度并不知道，这让网线主管不知所措。 你需要编写一个程序，
// 帮助网线主管确定一个最长的网线长度，并且按此长度对库存中的网线进行切割，能够得到指定数量的网线。

// 输入格式
// 第一行包含两个整数N和K，以单个空格隔开。N（1 <= N <= 10000）是库存中的网线数，K（1 <= K <= 10000）是需要的网线数量。
// 接下来N行，每行一个数，为库存中每条网线的长度（单位：米）。所有网线的长度至少1m，至多100km。输入中的所有长度都精确到厘米，即保留到小数点后两位。
// 输入样例
// 4 11
// 8.02
// 7.43
// 4.57
// 5.39

// 输出格式
// 网线主管能够从库存的网线中切出指定数量的网线的最长长度（单位：米）。必须精确到厘米，即保留到小数点后两位。
// 若无法得到长度至少为1cm的指定数量的网线，则必须输出“0.00”（不包含引号）。
// 输出样例
// 2.00

// 本道题同单元14 L2(下)考试

// 题目核心意思是要在网线数量够的前提下确定网线的最大长度。当确定一个长度，分割得的网线数不小于要求数，就说明按这个长度分割是够用的，
// 可以尝试更大的长度，如果该长度分割得的网线数比要求数少，就说明分割得太长了，得把长度减小。分析到这里，就明白这是个妥妥的二分答案题，
// 需要把网线分割长度二分再搜索。

#include <cstdio>
#include <iostream>
using namespace std;

int main() {
  int n, k; // n: 库存网线数  k: 需要网线数量 
  cin >> n >> k;
  double arr[10001], sum = 0, max=-1, res; // max表示最长的网线 res 输出结果
  for (int i = 0; i < n; i++) {
    cin >> arr[i];
    arr[i] = arr[i] * 100;
    sum += arr[i];
    if (max < arr[i]) {
      max = arr[i];
    }
  }
  // 无法得到长度至少为1cm的指定数量的网线
  if (sum < k) {
    cout << "0.00";
    return 0;
  }

  int l = 0, r = max, mid, count = 0;
  // 为什么必须 l+1 < r;
  // 假设是 l < r : 出现 l = 101, r = 102, 则mid = 101, 如果这时 count >= k, 则l = mid = 101, 会重复这个过程
  // 以本题给出的例子来说，最后会出现 200 < 201，最后陷入死循环
  // 假设是 l <= r: 出现 l = 100, r = 100, 则mid = 100, 如果这时 count >= k, 则l = mid = 100, 会重复这个过程
  // 如果是 l + 1 < r, l = 100, r= 102, 则 mid = 101, 无论是 count < k 还是 count >= k，都可以顺利跳出循环
  while (l + 1 < r) {
    mid = (l + r) / 2;
    
    for (int i = 0; i < n; i++) {
      count += arr[i]/mid;
    }
    // 如果赋值时 r = mid - 1; l = mid + 1; 则会丢失测试点
    // （不是精确查找某个数，精确查找某个数时，则如果中间值不是指定值，则直接忽略，这里是要寻找最接近的，则希望尽可能多覆盖） 
    if (count < k) {
      r = mid;
    } else {
      // 如果当前值满足题目要求，则暂时赋值，后面如果有满足条件要求的，还会继续更新
      res = mid;
      l = mid;
    }
    count = 0;
  }
  printf("%.2lf", res/100);
  return 0;
}




int main1() {
  int n, k; // n: 库存网线数  k: 需要网线数量 
  cin >> n >> k;
  double arr[10001], sum = 0, min=100000001, res; // min表示最短的网线 res 输出结果
  for (int i = 0; i < n; i++) {
    cin >> arr[i];
    arr[i] = arr[i] * 100;
    sum += arr[i];
    if (min > arr[i]) {
      min = arr[i];
    }
  }
  // 无法得到长度至少为1cm的指定数量的网线
  if (sum < k) {
    cout << "0.00";
    return 0;
  }
  // 下面这种想法这种错误的是：认为每段网线都必须利用到，所以理所当然认为最长长度必须比最短网线短
  // 从最短网线开始，计算每段网线切割数量，对比k，满足则退出，不满足则折半查找
  int l = 0, r = min * 2, count = 0;
  while (l < r) {
    // 进行二分搜索
    int mid = (l + r) / 2;
    for (int i = 0; i < n; i++) {
      count += arr[i] / mid;
    }
    if (count >= k) {
      l = mid + 1;
    } else {
      r = mid - 1;
    }
    count = 0;
    res = mid;
  }
  printf("%.2lf", res/100.0);
  return 0;
}