// 362
// 雇佣兵的体力最大值为M，初始体力值为0、战斗力为N、拥有X个能量元素。 当雇佣兵的体力值恰好为M时，才可以参加一个为期M天的战斗期，
// 战斗期结束体力值将为0。在同一个战斗期内，雇佣兵每连续战斗n天，战斗力就会上升1点，n为当前战斗期开始时的战斗力。 
// 一个战斗期结束后，雇佣兵需要用若干个能量元素使其体力恢复到最大值M，从而参加下一个战斗期。每个能量元素恢复的体力值不超过当前的战斗力。
// 每个能量元素只能使用一次。 请问：雇佣兵的战斗力最大可以到达多少。

// 输入格式
// 一行包括三个整数M、N、X，相邻两个整数之间用单个空格隔开。M、N、X均为不超过10000的正整数。
// 输入样例
// 5 2 10

// 每个能量元素恢复的体力值不超过当前的战斗力 （所以认为一个能量元素恢复n个体力值）
// 初始用3个能量元素，体力值到达5（其实是6，但是最大值为5） x = 7; m=5; 
// 此时战斗力为2，战斗5天，战斗力+2， 体力值清0； n = 4; m=0;
// 使用2个能量元素，体力值到达5（其实是8，但是最大值为5）；x = 5; m=5;
// 此时战斗力为4，战斗5天，战斗力+1；体力值清0； n = 5; m=0;
// 使用1个能量元素，体力值到达5 x = 4; m =5;
// 此时战斗力为5，战斗5天，战斗力+1；体力值清0; n = 6; m=0;
// 使用1个能量元素，体力值到达5（其实是6，但是最大值为5） x = 3; m = 5;
// 此时战斗力为6，但最多只能连续战斗5天，因此战斗力不会再增加，所以最大战斗力为6

// 输出格式
// 输出一个整数，为雇佣兵的最大战斗力。
// 输出样例
// 6

#include <cstdio>
int main() {
  int M, N, X;
  scanf("%d%d%d", &M, &N, &X);
  int m=0; // 初始体力值
  // 当战斗力大于最大体力值时，则无法提升战斗力，此时即为最大战斗力
  while (N <= M) {
    // 当体力值小于最大体力值时，无法参加战斗，需要花费能量元素补充体力值
    // 注意这里的条件， m < M: 而不是m<=M，因为当m==M的时候，已经达到最大体力值，无需花费能量元素补充能量

    // x >= 0而不是x>0，因为如果没有x == 0，那么循环跳出之后，可能m 未达到最大体力值M，
    // 下面的判断 if(x>=0) 认为x>=0就一定补充到了最大体力值，这个是有问题的，而加上x == 0的判断，进入循环，即使m达到了M，那么x会变成-1
    // 是消耗了一个不存在的能量值，进行下面的判断if (X >= 0) 就比较合理

    // 上面这种比较绕的话，可以使用X>0, 然后循环结束后，判断X>=0 && m >= M
    while (m < M && X > 0) {
    // while (m < M && X >= 0) {
      m += N;
      X--;
    }
    // 说明能量元素够补充到最大体力值
    if (X >= 0 && m >= M) {
    // if (X >= 0) {
      N += M / N;
      m = 0;
    } else {
      // 无法补充到最大体力值，无法参加战斗
      break;
    }
  }
  printf("%d", N);
  return 0;
}