// 1001
// 有一棵二叉树，最大深度为D，且所有叶子的深度都相同。 所有结点从上到下从左到右编号为1, 2, 3,…, 2^D-1。 
// 在结点1处放一个小球，它会往下落。 每个内结点上都有一个开关，初始全部关闭，当每次有小球落到一个开关上时，状态都会改变。
//  当小球到达一个内结点时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点。 一些小球从结点1处依次开始下落
//  ，最后一个小球将会落到哪里呢？输入叶子深度D（<=10）和小球个数，输出第I个小球最后所在的叶子编号。 
//  假设I不超过整棵树的叶子个数。 输入最多包含1000组数据。

// 输入格式
// 输入叶子深度D和小球个数I
// 输入样例
// 4 2
// 3 4
// 10 1
// 2 2
// 8 128

// 输出格式
// 第I个小球最后所在的叶子编号
// 输出样例
// 12
// 7
// 512
// 3 
// 255

// 思路：一个数组即可
// 假设深度为3，可以看出左子节点始终是父节点的两倍，右子节点是父节点的两倍+1
// 			1
// 	 2			3
// 4	 5	6		7

#include <cmath>
#include <iostream>
using namespace std;

int main() {
  int d, i;  // 叶子深度，小球个数,
  while (cin >> d >> i) {
    int diaoluo = 1; // 掉落小球
    int last = 1; // 掉落位置初始为1
    int arr[1024] = {0}; // 最大深度不超过10，则pow(2, 10) = 1024
    while (diaoluo <= i) {
      last = 1;
      // 掉落到第j层
      for (int j = 1; j < d; j++) {
        // 开关需要改变，而不是打开就不关闭
        if (arr[last] == 0) {
          arr[last] = 1;
          last = 2 * last;
        } else {
          arr[last] = 0;
          last = 2 * last + 1;
        }
      }
      if (diaoluo == i) {
        cout << last << endl;
      }
      diaoluo++;
    }
  }
  return 0;
}
